#include "RDumbTerminal.h"

/*------------------------------------------------------------------------------------------------------------------
-- SOURCE FILE: RDumbTerminal.c -  A Terminal emulator built to demonstrate forking and processes
--
-- PROGRAM: RFIDReader.exe
--
-- FUNCTIONS:
-- int main(void)
-- void catch_signal(int sig)
-- void err_exit(const char * error)
--
-- DATE: January 24th, 2018
--

--
-- DESIGNER: Delan Elliot
--
-- PROGRAMMER: Delan Elliot
--
-- NOTES:
-- Responsible for creating and ending processes. Forking and killing happens here.
----------------------------------------------------------------------------------------------------------------------*/




/*------------------------------------------------------------------------------------------------------------------
-- FUNCTION: main
--
-- DATE: January 24th 2018
--
-- REVISIONS:
--
-- DESIGNER: Delan Elliot
--
-- PROGRAMMER: Delan Elliot
--
-- INTERFACE: int main(void)
--
-- RETURNS: exit code
--
-- NOTES:
-- main spins up the pipes and processes, and passes each necessary pipe to each process. This design uses two pipes,
-- one for passing from the input to the translation process, and one pipe to output to the console. The output pipe is
-- shared between input and translate.
----------------------------------------------------------------------------------------------------------------------*/
int main(void)
{
	int i_pipe[2];
	int t_pipe[2];

	signal(SIGABRT, catch_signal);
	signal(SIGTERM, catch_signal);

	system("stty raw igncr -echo");

	if (pipe(i_pipe) < 0)
	{
		err_exit("input pipe failed");
	}

	if (pipe(t_pipe) < 0)
	{
		err_exit("translate pipe failed");
	}
	/*in new thread*/
	if ((translate_p = fork()) == 0)
	{
		translate(i_pipe, t_pipe);
	}
	else if (translate_p == -1)
	{
		err_exit("translate fork failed");
	}
	/* Still in main thread*/
	else
	{
		/* in second child thread*/
		if ((output_p = fork()) == 0)
		{
			output(i_pipe);
		}
		/* Still in main thread */
		else
		{
			input_p = getpid();
			input(i_pipe, t_pipe);
		}
	}

}


/*------------------------------------------------------------------------------------------------------------------
-- FUNCTION: catch_signal
--
-- DATE: January 24th 2018
--
-- REVISIONS:
--
-- DESIGNER: Delan Elliot
--
-- PROGRAMMER: Delan Elliot
--
-- INTERFACE: void catch_signal(int sig)
--
-- RETURNS: void
--
-- NOTES:
-- catch_signal is mapped to catch SIGTERM and SIGABRT which are generated by the input.c process. These signals will then
-- end all the processes in the desired manner.
----------------------------------------------------------------------------------------------------------------------*/
void catch_signal(int sig)
{
	switch (sig)
	{


	case 6:
		signal(SIGABRT,NULL);

		if(getpid() == input_p)
		{
			system("stty -raw -igncr echo");
		}
		kill(output_p, SIGABRT);
		kill(translate_p, SIGABRT);
		kill(getpid(), SIGABRT);

		break;
	case 15:
		signal(SIGTERM, NULL);
		if(getpid() == input_p)
		{
			system("stty -raw -igncr echo");
		}
		kill(output_p, SIGTERM);
		kill(translate_p, SIGTERM);
		kill(getpid(), SIGTERM);
		break;
	}
}


/*------------------------------------------------------------------------------------------------------------------
-- FUNCTION: err_exit
--
-- DATE: January 24th 2018
--
-- REVISIONS:
--
-- DESIGNER: Delan Elliot
--
-- PROGRAMMER: Delan Elliot
--
-- INTERFACE: void err_exit(const char * error)
--
-- RETURNS: void
--
-- NOTES:
-- This function exits the program gracefully and resets TTY handling/restores sanity when any of the processes encounter an error.
-- Prints the reason for exit and then terminates.
----------------------------------------------------------------------------------------------------------------------*/
void err_exit(const char * error)
{
	perror(error);
	if (getpid() == input_p)
	{
		system("stty -raw -igncr echo");
	}
	kill(translate_p, SIGTERM);
	kill(output_p, SIGTERM);
	kill(getpid(), SIGTERM);
}
